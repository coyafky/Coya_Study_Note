

## 进程的现实例子

考虑一个网络服务器。从各处进入一些网页请求。当一个请求进入时， 服务器检查是否其需要的网页在缓存中。如果是，则把网页发送回去；如果不 是，则启动一个磁盘请求以获取网页。然而，从CPU的角度来看，磁盘请求需要 漫长的时间。当等待磁盘请求完成时，其他更多的请求将会进入。如果有多个磁 盘存在，会在满足第一个请求之前就接二连三地对其他的磁盘发出一些或所有的 请求。很明显，需要一些方法去模拟并控制这种并发。进程（特别是线程）在这 里就可以产生作用



进程模型

计算机上所有可运行的软件，通常也包括操作系统，被组织 成若干顺序进程（sequential process），简称进程（process）

<u>一个进程就是一个 正在执行程序的实例</u>



![截屏2023-11-13 00.15.29](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/截屏2023-11-13 00.15.29.png)



进程和程序之间的分别

程序-做蛋糕的食谱

进程- 是厨师阅读食谱，调取原料制作蛋糕等一系列动作的总和

```txt
想象一位有一手好厨艺的计算机科学家正在为他的女儿烘制生日 蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁 等。在这个比喻中，做蛋糕的食谱就是程序（即用适当形式描述的算法），计算 机科学家就是处理器（CPU），而做蛋糕的各种原料就是输入数据。进程就是厨 师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。 现在假设计算机科学家的儿子哭着跑了进来，说他的头被一只蜜蜂螫了。计 算机科学家就记录下他照着食谱做到哪儿了（保存进程的当前状态），然后拿出 一本急救手册，按照其中的指示处理蛰伤。这里，我们看到处理机从一个进程 （做蛋糕）切换到另一个高优先级的进程（实施医疗救治），每个进程拥有各自 的程序（食谱和急救手册）。当蜜蜂螫伤处理完之后，这位计算机科学家又回来 做蛋糕，从他离开时的那一步继续做下去。
```

**一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停 止一个进程的工作，并转而为另一个进程提供服务。**



### 创建进程

- 系统的初始化
- 执行了正在运行的进程所调用的进程创建系统调用
- 用户请求创建一个新进程
- 一个批系统作业的初始化







### 进程的终止

进程终止的条件

1.正常退出（自愿）

2.出错退出（自愿）

3.严重错误（非自愿）

4.被其他进程杀死（非自愿）





### 进程的层次结构

当进程创建了另一个进程后，父进程和子进程就以某种形式继 续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构

进程只有一个父进程（但是可以有零个、 一个、两个或多个子进程）





### 进程的状态

 当一个进程在逻辑上不能继续运行时，它就会被阻塞

它在等待可以使用的输入。还可能有这样的情况：一个概念上能够运行的进程被迫停 止，因为操作系统调度另一个进程占用了CPU。



1)运行态（该时刻进程实际占用CPU）。 

2)就绪态（可运行，但因为其他进程正在运行而暂时停止）。 

3)阻塞态（除非某种外部事件发生，否则进程不能运行）。

![截屏2023-11-13 00.27.50](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/进程的3种状态.png)





在操作系统发现 进程不能继续运行下去时，发生转换1

```
某些系统中，进程可以执行一个诸如 pause的系统调用来进入阻塞状态。在其他系统中，包括UNIX，当一个进程从管 道或设备文件（例如终端）读取数据时，如果没有有效的输入存在，则进程会被自动阻塞
```

转换2和3是由进程调度程序引起的(**调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间**)

系统认为一个运行进程占用处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2

在系统已经让所有其他 进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时，会 发生转换3

进程等待的一个外部事件发生时（如一些输入到达则发生转换4。如果此时没有其他进程运行，则立即触发转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行











### 进程的实现

进程模型，操作系统维护着一张表格（一个结构数组），即进程表 （process table）。每个进程占用一个进程表项。![截屏2023-11-13 00.38.06](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/进程表.png)

```
在了解进程表后，就可以对在单个（或每一个）CPU上如何维持多个顺序进 程的错觉做更多的阐述。与每一I/O类关联的是一个称作中断向量（interrupt vector）的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地 址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数 器、程序状态字，有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断 向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例 程就接管一切剩余的工作。 所有的中断都从保存寄存器开始，对于当前进程而言，通常是在进程表项 中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指 针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆 栈指针等操作，无法用C语言这一类高级语言描述，所以这些操作通过一个短小 的汇编语言例程来完成，通常该例程可以供所有的中断使用，因为无论中断是怎 样引起的，有关保存寄存器的工作则是完全一样的
```







### CPU利用率





## 线程

每个进程有一个地址空间和一个控制线程。事实上，这 几乎就是进程的定义



线程的使用



```
第一个例子，考虑一个字处理软件。字处理软件通常按照出现在打印页上的格式 在屏幕上精确显示文档。特别地，所有的行分隔符和页分隔符都在正确的最终位 置上，这样在需要时用户可以检查和修改文档（比如，消除孤行——在一页上不 完整的顶部行和底部行，因为这些行不甚美观）。 假设用户正在写一本书。从作者的观点来看，最容易的方法是把整本书作为 一个文件，这样一来，查询内容、完成全局替换等都非常容易。另一种方法是， 把每一章都处理成单独一个文件。但是，在把每个小节和子小节都分成单个的文 件之后，若必须对全书进行全局的修改时，那就真是麻烦了，因为有成百个文件 必须一个个地编辑。例如，如果所建议的某个标准xxxx正好在书付印之前被批准 了，于是“标准草案xxxx”一类的字眼就必须改为“标准xxxx”。如果整本书是一个 文件，那么只要一个命令就可以完成全部的替换处理。相反，如果一本书分成了 300个文件，那么就必须分别对每个文件进行编辑。个文件，那么就必须分别对每个文件进行编辑。 现在考虑，如果有一个用户突然在一个有800页的文件的第一页上删掉了一 个语句之后，会发生什么情形。在检查了所修改的页面并确认正确后，这个用户 现在打算接着在第600页上进行另一个修改，并键入一条命令通知字处理软件转 到该页面（可能要查阅只在那里出现的一个短语）。于是字处理软件被强制对整 个书的前600页重新进行格式处理，这是因为在排列该页前面的所有页面之前， 字处理软件并不知道第600页的第一行应该在哪里。而在第600页的页面可以真正 在屏幕上显示出来之前，计算机可能要拖延相当一段时间，从而令用户不甚满 意。
```





### 经典的线程模型

模型。 理解进程的一个角度是，用某种方法把相关的资源集中在一起。进程有存放 程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进 程、即将发生的报警、信号处理程序、账号信息等。把它们都放到进程中可以更 容易管理。 另一个概念是，进程拥有一个执行的线程，通常简写为线程（thread）。在 线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器， 用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中 每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进 程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把 资源集中到一起，而线程则是在CPU上被调度执行的实体。



![截屏2023-11-13 01.26.42](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/线程模型.png)





![截屏2023-11-13 08.33.37](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/进程中的线程共享内容.png)

第一列表项是进程的属性，而不是线程的属性。例如，如果一个 线程打开了一个文件，该文件对该进程中的其他线程都可见，这些线程可以对该 文件进行读写。由于资源管理的单位是进程而非线程

线程概念试图实现的是，共享一组资源的多个线程的执行 能力，以便这些线程可以为完成某一任务而共同工作。

传统进程一样（即只有一个线程的进程），线程可以处于若干种状态的任何一个：运行、阻塞、就绪或终止

每个线程有其自己的堆栈

例如，如果过程X调用过程 Y，而Y又调用Z，那么当Z执行时，供X、Y和Z使用的帧会全部存在堆栈中

![截屏2023-11-13 08.36.41](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/每一个线程都有自己的堆栈.png)







### 在用户空间实现线程



整个线程包放在用户空间中，内核对线程包一无所知。从内 核角度考虑，就是按正常的方式管理，即单线程进程。这种方法第一个，也是最 明显的优点是，用户级线程包可以在不支持线程的操作系统上实现。过去所有的 操作系统都属于这个范围

线程在一个运行时系 统的顶部运行，这个运行时系统是一个管理线程的过程的集合

四个过程：pthread_create，pthread_exit，pthread_join和pthread_yield

<img src="/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/用户级线程包.png" alt="截屏2023-11-13 08.39.09" style="zoom:67%;" />



用户级线程还有另一个优点。它允许每个进程有自己定制的调度算法。例 如

问题。其中第一个 问题是如何实现阻塞系统调用



### 在内核实现线程

![截屏2023-11-13 08.42.40](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/内核管理的线程包.png)







### 混合实现

用户级线程的优点和内核级线程的优点结合起来 的方法。

一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线 **程多路复用起来**

![截屏2023-11-13 08.44.05](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/内核线程和用户级线程多路复用.png)

## 调度程序激活机制

尽管内核级线程在一些关键点上优于用户级线程，但无可争议的是内核级线 程的速度慢（解决方法是调度程序激活）

调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在 用户空间中才能实现的更好的性能和更大的灵活性





## 弹出式编程

在该处理方式中，一个消息的 到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程，

弹出式线程的关键好处是，由于这种线程相当新，没有历史——没有必须 存储的寄存器、堆栈诸如此类的内容，每个线程从全新开始，每一个线程彼此之 间都完全一样。这样，就有可能快速创建这类线程。对该新线程指定所要处理的 消息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。

![截屏2023-11-14 00.11.43](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/弹出式线程.png)





## 进程间的通信

### 竞争条件

一个假脱机打印 程序。当一个进程需要打印一个文件时，它将文件名放在一个特殊的假脱机目录 （spooler directory）下。另一个进程（打印机守护进程）则周期性地检查是否有 文件需要打印

```
设想假脱机目录中有许多槽位，编号依次为0，1，2，…，每个槽位存放一 个文件名。同时假设有两个共享变量：out，指向下一个要打印的文件；in，指向 目录中下一个空闲槽位。可以把这两个变量保存在一个所有进程都能访问的文件 中，该文件的长度为两个字。在某一时刻，0号至3号槽位空（其中的文件已经打 印完毕），4号至6号槽位被占用（其中存有排好队列的要打印的文件名）。几乎 在同一时刻，进程A和进程B都决定将一个文件排队打印，这种情况如图2-21所 示。 图 2-21 两个进程同时想访问共享内存 在Murphy法则（任何可能出错的地方终将出错）生效时，可能发生以下的情 况。进程A读到in的值为7，将7存在一个局部变量next_free_slot中。此时发生一次 时钟中断，CPU认为进程A已运行了足够长的时间，决定切换到进程B。进程B也 读取in，同样得到值为7，于是将7存在B的局部变量next_free_slot中。在这一时刻 两个进程都认为下一个可用槽位是7
```

![截屏2023-11-13 08.50.43](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/2个进程同时想访问共享内存.png)



即两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件（race condition）



### 临界区

避免竞争条件 关键是要找出某种途径来阻 止多个进程同时读写共享的数据。换言之，我们需要的是互斥（mutual exclusion

在某些时候进程可能需要 访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域（critical region）或临界区（critica）

满足4个条件

1)任何两个进程不能同时处于其临界区。 

2)不应对CPU的速度和数量做任何假设。

3)临界区外运行的进程不得阻塞其他进程。 

4)不得使进程无限期等待进入临界区



![截屏2023-11-13 08.54.30](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/使用临界区的互斥.png)



### 忙等待的互斥

#### 屏蔽中断

在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏 蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。 CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后 CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检 查和修改共享内存，而不必担心其他进程介入



对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽 是很方便的。当就绪进程队列之类的数据状态不一致时发生中断，则将导致竞争 条件。所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对 于用户进程则不是一种合适的通用互斥机制



在一个多核系统中（例如，多处理器系统），屏蔽一个CPU的中断不会阻止 其他CPU干预第一个CPU所做的操作。结果是人们需要更加复杂的计划。



#### 锁变量

可以寻找一种软件解决方案。设想有一个共享（锁）变 量，其初始值为0。当一个进程想进入其临界区时，它首先测试这把锁。如果该 锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该 进程将等待直到其值变为0。于是，0就表示临界区内没有进程，1表示已经有某 个进程进入临界区。

bug

想法也包含了与假脱机目录一样的疏漏。假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行， 将该锁变量设置为1。当第一个进程再次能运行时，它同样也将该锁设置为1，则 此时同时有两个进程进入临界区中



#### 严格轮换法

整型变量turn，初始值为0，用于记录轮到哪个进程进入临界 区，并检查或更新共享内存。开始时，进程0检查turn，发现其值为0，于是进入 临界区。进程1也发现其值为0，所以在一个等待循环中不停地测试turn，看其值 何时变为1。连续测试一个变量直到某个值出现为止，称为忙等待（busy waiting）。

由于这种方式浪费CPU时间，所以通常应该避免

有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待 的锁，称为自旋锁（spin lock）。





![截屏2023-11-14 00.15.24](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/忙等待转换法.png)

#### Peterson解法



![截屏2023-11-14 00.17.23](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/Peterson解法.png)

#### TSL指令







### 睡眠与唤醒

#### 生产者和消费者问题









### 信号量





### 互斥量



### 管程





### 消息传递



### 屏障

![截屏2023-11-14 00.19.13](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/屏障的使用.png)







## 调度

##                                 



### 调度介绍

#### 进程行为



![截屏2023-11-14 00.27.50](/Users/mc/Library/Application Support/typora-user-images/截屏2023-11-14 00.27.50.png)





2.何时调度 有关调度处理的一个关键问题是何时进行调度决策。存在着需要调度处理的 各种情形。

第一，在创建一个新进程之后，需要决定是运行父进程还是运行子进 程。由于这两种进程都处于就绪状态，所以这是一种正常的调度决策，可以任意 决定，也就是说，调度程序可以合法选择先运行父进程还是先运行子进程。 

第二，在一个进程退出时必须做出调度决策。一个进程不再运行（因为它不 再存在），所以必须从就绪进程集中选择另外某个进程。如果没有就绪的进程， 通常会运行一个系统提供的空闲进程。

 第三，当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另 一个进程运行。有时，阻塞的原因会成为选择的因素。例如，如果A是一个重要 的进程，并正在等待B退出临界区，让B随后运行将会使得B退出临界区，从而可 以让A运行。不过问题是，通常调度程序并不拥有做出这种相关考虑的必要信 息。 

第四，在一个I/O中断发生时，必须做出调度决策。如果中断来自I/O设备， 而该设备现在完成了工作，某些被阻塞的等待该I/O的进程就成为可运行的就绪进 程了。是否让新就绪的进程运行，这取决于调度程序的决定，或者让中断发生时 运行的进程继续运行，或者应该让某个其他进程运行。





### 调度的算法分类

不同的环境需要不同的调度算法。之所以出现这种情形，是因为 不同的应用领域（以及不同的操作系统）有不同的目标。换句话说，在不同的系 统中，调度程序的优化是不同的。这里有必要划分出三种环境：

 1)批处理。

 2)交互式。

 3)实时。





调度算法的目标



![截屏2023-11-14 00.29.15](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/进程/image/调度算法的目标.png)

### 批处理中的调度



#### 先来后到服务



#### 最短作业优先



#### 最短剩余时间优先



### 交互式系统中的调度



#### 轮转调度

![截屏2023-11-14 00.31.31](/Users/mc/Library/Application Support/typora-user-images/截屏2023-11-14 00.31.31.png)



优先级调度



#### 多级队列



#### 最短进程时间优先





#### 保证调度



#### 彩票制度



#### 公平分享调度






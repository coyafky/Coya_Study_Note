

# 存储管理



操作系统中管理分层存储器体系的部分称为存储管理器（memory manager）。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些 内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存



## 存储器抽象：地址空间

为什么需要

物理地址暴露会毁坏操作系统

把物理地址暴露给进程会带来下面几个严重问题。第一，如果用户程 序可以寻址内存的每个字节，它们就可以很容易地（故意地或偶然地）破坏操作 系统，从而使系统慢慢地停止运行（除非有特殊的硬件进行保护，如IBM 360的 锁键模式）。即使在只有一个用户进程运行的情况下





### 地址空间的概念

要保证多个应用程序同时处于内存中并且不互相影响，则需要解决两个问题保护和重定位



创造一个新的内存抽象：地址空间。就像进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地 址空间，并且这个地址空间独立于其他进程的地址空间



使用基址寄存器和界限寄存器可以为每一个进程提供一个独立的地址空间

![截屏2023-11-15 01.04.53](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/存储器/image/存储器.png)

基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加 法和比较运算。比较可以做得很快，但是加法由于进位传递时间的问题，在没有 使用特殊电路的情况下会显得很慢





### 交换技术

背景,所有进程所需要的RAM数量总和超过存储器所支持的范围

例子

在一个典型的Windows或Linux系统中，在计算机完成引 导后，会启动40～60个，甚至更多的进程。

```
Windows或Linux系统中，在计算机完成引 导后，会启动40～60个，甚至更多的进程。例如，当一个Windows应用程序安装 后，通常会发出一系列命令，使得在此后的系统引导中会启动一个仅仅用于查看 该应用程序更新的进程。这样一个进程会轻易地占据5～10MB的内存。其他后台 进程还会查看所收到的邮件和进来的网络连接，以及其他很多诸如此类的任务。 并且，这一切都发生在第一个用户程序启动之前。当前重要的应用程序能轻易地 占据50～200MB甚至更多的空间。因此，把所有进程一直保存在内存中需要巨大 的内存，如果内存不够，就做不到这一点。
```



处理内存超载的方法

交换（swapping）即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘，所以当它们不运行时就不会占用内存（尽管它们的一些 进程会周期性地被唤醒以完成相关工作，然后就又进入睡眠状态）

另一种策略 是虚拟内存（virtual memory），该策略甚至能使程序在只有一部分被调入内存的 情况下运行



![截屏2023-11-15 01.09.00](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/存储器/image/交换.png)





但大部分进程在运行的时候都需要增长

为了减少因内存区域不够而引起的进程 交换和移动所产生的开销，一种可用的方法是，当换入或移动进程时为它分配一 些额外的内存。然而，当进程被换出到磁盘上时，应该只交换进程实际上使用的 内存中的内容，将额外的内存交换出去是一种浪费。在图3-5a中读者可以看到一 种已为两个进程分配了增长空间的内存配置

![截屏2023-11-15 01.11.16](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/存储器/image/预留位置.png)



```
如果进程有两个可增长的段，例如，供变量动态分配和释放的作为堆使用的 一个数据段，以及存放普通局部变量与返回地址的一个堆栈段，则可使用另一种 安排，如图3-5b所示。在图中可以看到所示进程的堆栈段在进程所占内存的顶端 并向下增长，紧接在程序段后面的数据段向上增长。在这两者之间的内存可以供 两个段使用。如果用完了，进程或者必须移动到足够大的空闲区中（它可以被交 换出内存直到内存中有足够的空间），或者结束该进程。
```





### 空闲内存管理



#### 使用位图的存储管理

![截屏2023-11-15 01.12.35](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/存储器/image/使用位图的存储管理.png)





#### 使用链表的存储管理

![截屏2023-11-15 01.13.28](/Users/mc/Library/Application Support/typora-user-images/截屏2023-11-15 01.13.28.png)





### 虚拟内存

采用的这个方法（Fotheringham，1961）称为虚拟内存（virtual memory）。 

虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或（page）。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一 部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一 部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存 并重新执行失败的指令。

#### 分页



![截屏2023-11-15 01.14.45](/Users/mc/Documents/code/Coya_Study_Note/计算机操作系统/存储器/image/MMU位置和功能.png)





虚拟内存和物理内存地址的映射关系



![截屏2023-11-15 01.15.21](/Users/mc/Library/Application Support/typora-user-images/截屏2023-11-15 01.15.21.png)







#### 页表



页表项



![截屏2023-11-15 01.16.29](/Users/mc/Library/Application Support/typora-user-images/截屏2023-11-15 01.16.29.png)